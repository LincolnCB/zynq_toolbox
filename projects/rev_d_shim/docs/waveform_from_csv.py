import csv
import sys
import os
import math

#!/usr/bin/env python3
"""
DAC Waveform Generator from CSV

This script generates DAC waveform files from a CSV file.
- The first column is time in seconds.
- The remaining columns are DAC channel values in amps.
- Each line is either a T (trigger) or D (delay) command.
- If time == 0, it's a T command for 1 trigger.
- If time > previous, it's a D command with delay = (current_time - last_trigger_time) in clock cycles, minus cumulative delay since last trigger.
- If time < previous and not 0, error.

If there are more than 8 channels, each group of 8 is written to a separate file (_bd0, _bd1, ...).
If the last group has fewer than 8 channels, fill with zeros.

Optionally, generates an ADC readout command file, board-agnostic.
- Prompts for ADC sample rate (Hz) and extra sample time (seconds).
- ADC triggers align with DAC triggers, then samples at the given rate for the time between triggers plus extra time.

Author: Generated for rev_d_shim project
"""

def prompt_float(prompt, minval=None):
  while True:
    try:
      val = float(input(prompt))
      if minval is not None and val < minval:
        print(f"Value must be >= {minval}")
        continue
      return val
    except ValueError:
      print("Please enter a valid number.")

def prompt_yes_no(prompt):
  while True:
    ans = input(prompt + " [y/n]: ").strip().lower()
    if ans in ('y', 'yes'):
      return True
    if ans in ('n', 'no'):
      return False
    print("Please enter y or n.")

def current_to_dac_value(current_amps):
  # -5.1A to +5.1A maps to -32767 to +32767
  dac_value = int(current_amps * 32767 / 5.1)
  return max(-32767, min(32767, dac_value))

def split_channels(row, n_channels):
  # row: [time, ch0, ch1, ...]
  # returns list of lists, each with 8 channels (pad with zeros if needed)
  out = []
  for i in range(0, n_channels, 8):
    group = row[i:i+8]
    if len(group) < 8:
      group += [0.0] * (8 - len(group))
    out.append(group)
  return out

def write_adc_file(section_durations, base_name, adc_sample_rate_khz, adc_extra_time, spi_clock_freq_mhz):
  """
  Write an ADC readout command file.
  
  The file format follows the ADC command structure:
  - T <value>: Trigger command (waits for trigger)
  - D <delay> <repeat_count>: Delay command (reads with delay timing, repeating additional times)
  - O <ch0> <ch1> ... <ch7>: Order command (sets channel order)
  
  Args:
    section_durations: List of section durations in seconds (one per trigger section)
    base_name: Base filename for output
    adc_sample_rate_khz: ADC sample rate in kHz
    adc_extra_time: Extra sampling time in seconds to add to each section
    spi_clock_freq_mhz: SPI clock frequency in MHz
  """
  adc_filename = f"{base_name}.rdout"
  
  # Calculate delay value for ADC sample rate
  # Convert kHz to ksps and use SPI clock frequency in MHz
  adc_sample_rate_ksps = adc_sample_rate_khz
  spi_clock_freq_hz = spi_clock_freq_mhz * 1000000
  adc_sample_rate_hz = adc_sample_rate_ksps * 1000
  cycles_per_sample = spi_clock_freq_hz / adc_sample_rate_hz
  adc_delay_value = max(1, min(33554431, int(cycles_per_sample)))
  
  with open(adc_filename, 'w') as f:
    f.write("# ADC Readout Command File\n")
    f.write(f"# Generated by waveform_from_csv.py\n")
    f.write(f"# ADC sample rate: {adc_sample_rate_ksps:.6g} ksps\n")
    f.write(f"# SPI clock frequency: {spi_clock_freq_mhz:.6g} MHz\n")
    f.write(f"# ADC delay value: {adc_delay_value}\n")
    f.write(f"# Extra sample time per section: {adc_extra_time * 1000:.6g} ms\n")
    f.write(f"# Number of trigger sections: {len(section_durations)}\n")
    f.write("# Format: T <value> (trigger) / D <delay> <repeat_count> (delay/read) / O <ch0> <ch1> ... <ch7> (order)\n")
    f.write("#\n")
    
    # Write channel order command (sets ADC channel order to 0 1 2 3 4 5 6 7)
    f.write("# Order command: set ADC channel order to 0 1 2 3 4 5 6 7\n")
    f.write("O 0 1 2 3 4 5 6 7\n")
    f.write("#\n")
    
    # Write commands for each trigger section
    total_samples = 0
    for i, section_duration_s in enumerate(section_durations):
      # Add extra time to this section
      total_section_time_s = section_duration_s + adc_extra_time
      if total_section_time_s <= 0:
        total_section_time_s = adc_extra_time
      
      # Calculate samples for this section
      section_samples = int(adc_sample_rate_ksps * total_section_time_s * 1000)  # Convert s to ms
      if section_samples < 1:
        section_samples = 1
      
      total_samples += section_samples
      
      f.write(f"# Section {i + 1}: duration={section_duration_s * 1000:.6g}ms + {adc_extra_time * 1000:.6g}ms extra = {total_section_time_s * 1000:.6g}ms, samples={section_samples}\n")
      f.write("# Trigger command: wait for 1 trigger to start sampling\n")
      f.write("T 1\n")
      
      # Write delay command with repeat count
      repeat_count = section_samples - 1  # First execution doesn't count as repeat
      f.write(f"# Delay command: read ADC with {adc_delay_value} cycle delay, repeating an additional {repeat_count} times\n")
      f.write(f"D {adc_delay_value} {repeat_count}\n")
      f.write("#\n")
  
  print(f"ADC readout file written to: {adc_filename}")
  print(f"Number of trigger sections: {len(section_durations)}")
  print(f"Total samples across all sections: {total_samples}")
  print(f"ADC delay value: {adc_delay_value}")

def main():
  if len(sys.argv) < 2:
    print("Usage: waveform_from_csv.py <input.csv>")
    sys.exit(1)
  csv_file = sys.argv[1]
  if not os.path.exists(csv_file):
    print(f"File not found: {csv_file}")
    sys.exit(1)

  spi_clock_freq = prompt_float("SPI clock frequency (MHz): ", minval=0.001)
  spi_clock_hz = spi_clock_freq * 1e6

  # Read CSV
  with open(csv_file, newline='') as f:
    reader = csv.reader(f)
    rows = []
    for row in reader:
      if not row or all(cell.strip() == '' for cell in row):
        continue
      try:
        time = float(row[0])
        samples = [float(x) for x in row[1:]]
        rows.append([time] + samples)
      except Exception as e:
        print(f"Error parsing row: {row}\n{e}")
        sys.exit(1)

  if not rows:
    print("No data found in CSV.")
    sys.exit(1)

  n_channels = len(rows[0]) - 1
  n_bd = math.ceil(n_channels / 8)

  # Pad all rows to multiple of 8 channels
  for i in range(len(rows)):
    samples = rows[i][1:]
    if len(samples) < n_bd * 8:
      samples += [0.0] * (n_bd * 8 - len(samples))
      rows[i] = [rows[i][0]] + samples

  base_name = os.path.splitext(os.path.basename(csv_file))[0]

  # Calculate section durations (time from each trigger to end of that section)
  section_durations = []
  current_section_start_time = 0.0
  
  for idx, row in enumerate(rows):
    time = row[0]
    if idx == 0 or time == 0:
      # This is a trigger - end the previous section if we have one
      if idx > 0:
        # Calculate duration of previous section
        section_duration = rows[idx-1][0] - current_section_start_time
        section_durations.append(section_duration)
      # Start new section
      current_section_start_time = time
  
  # Add the final section duration
  if rows:
    final_section_duration = rows[-1][0] - current_section_start_time
    section_durations.append(final_section_duration)

  for bd in range(n_bd):
    out_rows = []
    last_trigger_time = 0.0
    last_time = 0.0
    last_cum_delay = 0
    cum_delay = 0
    for idx, row in enumerate(rows):
      time = row[0]
      ch_start = 1 + bd * 8
      ch_end = ch_start + 8
      ch_vals = row[ch_start:ch_end]
      # Convert to DAC values
      ch_vals_dac = [current_to_dac_value(val) for val in ch_vals]
      if idx == 0 or time == 0:
        # Trigger command
        out_rows.append(('T', 1, ch_vals_dac))
        last_trigger_time = time
        last_cum_delay = 0
        cum_delay = 0
      else:
        if time < last_time and time != 0:
          print(f"Error: time decreased from {last_time} to {time} at row {idx}")
          sys.exit(1)
        # Calculate delay in clock cycles
        total_delay = int(round((time - last_trigger_time) * spi_clock_hz))
        delay = total_delay - cum_delay
        if delay < 1:
          delay = 1
        out_rows.append(('D', delay, ch_vals_dac))
        cum_delay += delay
      last_time = time

    out_filename = f"{base_name}_bd{bd}.wfm"
    with open(out_filename, 'w') as f:
      f.write(f"# DAC Waveform File from CSV\n")
      f.write(f"# Board: {bd}\n")
      f.write(f"# Source file: {csv_file}\n")
      f.write(f"# SPI clock frequency: {spi_clock_freq:.6g} MHz\n")
      f.write(f"# Channels: {min(8, n_channels - bd*8)}\n")
      f.write("# Format: T 1 <ch0-ch7> (trigger) / D <delay> <ch0-ch7> (delay)\n")
      for cmd, val, chs in out_rows:
        line = f"{cmd} {val}"
        for ch in chs:
          line += f" {ch}"
        f.write(line + "\n")
    print(f"Wrote {out_filename}")

  # Prompt for ADC readout command file
  if prompt_yes_no("Generate ADC readout command file?"):
    adc_sample_rate_khz = prompt_float("ADC sample rate (kHz): ", minval=0.001)
    adc_extra_time = prompt_float("Extra sample time after each trigger (seconds): ", minval=0)
    write_adc_file(section_durations, base_name, adc_sample_rate_khz, adc_extra_time, spi_clock_freq)

if __name__ == "__main__":
  main()
