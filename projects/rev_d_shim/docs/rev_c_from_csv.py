import csv
import sys
import os
import math

#!/usr/bin/env python3
"""
DAC/ADC Command File Generator from CSV (Rev C style)

- Input CSV: Each row is a DAC trigger update (no time column).
- Each row: ch0, ch1, ..., chN (amps)
- Output: For each group of 8 channels, a _bdN.wfm file with T 1 <ch0-ch7> per row.
- ADC: For each DAC trigger, output:
  T 1
  D <adc_delay_cycles>
  D <adc_delay_cycles>
  (two D lines per trigger, as requested)

Prompts for:
- SPI clock frequency (MHz)
- ADC delay (ms)

Author: Generated for rev_c_shim project
"""


def prompt_float(prompt, minval=None):
  while True:
    try:
      val = float(input(prompt))
      if minval is not None and val < minval:
        print(f"Value must be >= {minval}")
        continue
      return val
    except ValueError:
      print("Please enter a valid number.")

def prompt_yes_no(prompt):
  while True:
    ans = input(prompt + " [y/n]: ").strip().lower()
    if ans in ('y', 'yes'):
      return True
    if ans in ('n', 'no'):
      return False
    print("Please enter y or n.")

def current_to_dac_value(current_amps):
  # -5.1A to +5.1A maps to -32767 to +32767
  dac_value = int(current_amps * 32767 / 5.1)
  return max(-32767, min(32767, dac_value))

def main():
  if len(sys.argv) < 2:
    print("Usage: rev_c_from_csv.py <input.csv>")
    sys.exit(1)
  csv_file = sys.argv[1]
  if not os.path.exists(csv_file):
    print(f"File not found: {csv_file}")
    sys.exit(1)

  spi_clock_freq = prompt_float("SPI clock frequency (MHz): ", minval=0.001)
  spi_clock_hz = spi_clock_freq * 1e6

  # Read CSV
  with open(csv_file, newline='') as f:
    reader = csv.reader(f)
    rows = []
    for row in reader:
      if not row or all(cell.strip() == '' for cell in row):
        continue
      try:
        samples = [float(x) for x in row]
        rows.append(samples)
      except Exception as e:
        print(f"Error parsing row: {row}\n{e}")
        sys.exit(1)

  if not rows:
    print("No data found in CSV.")
    sys.exit(1)

  n_channels = len(rows[0])
  n_bd = math.ceil(n_channels / 8)

  # Pad all rows to multiple of 8 channels
  for i in range(len(rows)):
    samples = rows[i]
    if len(samples) < n_bd * 8:
      samples += [0.0] * (n_bd * 8 - len(samples))
      rows[i] = samples

  base_name = os.path.splitext(os.path.basename(csv_file))[0]

  # Write DAC waveform files
  for bd in range(n_bd):
    out_filename = f"{base_name}_bd{bd}.wfm"
    with open(out_filename, 'w') as f:
      f.write(f"# DAC Waveform File from CSV (Rev C style)\n")
      f.write(f"# Board: {bd}\n")
      f.write(f"# Source file: {csv_file}\n")
      f.write(f"# SPI clock frequency: {spi_clock_freq:.6g} MHz\n")
      f.write(f"# Channels: {min(8, n_channels - bd*8)}\n")
      f.write("# Format: T 1 <ch0-ch7> (trigger)\n")
      for row in rows:
        ch_start = bd * 8
        ch_end = ch_start + 8
        ch_vals = row[ch_start:ch_end]
        ch_vals_dac = [current_to_dac_value(val) for val in ch_vals]
        line = "T 1"
        for ch in ch_vals_dac:
          line += f" {ch}"
        f.write(line + "\n")
    print(f"Wrote {out_filename}")

  # ADC command file
  if prompt_yes_no("Generate ADC readout command file?"):
    adc_delay_ms = prompt_float("ADC delay (ms): ", minval=0.001)
    adc_delay_s = adc_delay_ms / 1000.0
    adc_delay_cycles = int(round(adc_delay_s * spi_clock_hz))
    adc_filename = f"{base_name}.rdout"
    with open(adc_filename, 'w') as f:
      f.write("# ADC Readout Command File (Rev C style)\n")
      f.write(f"# Generated by rev_c_from_csv.py\n")
      f.write(f"# SPI clock frequency: {spi_clock_freq:.6g} MHz\n")
      f.write(f"# ADC delay: {adc_delay_ms:.6g} ms ({adc_delay_cycles} cycles)\n")
      f.write("# For each DAC trigger, two D commands follow (for future use)\n")
      f.write("# Format: T 1 (trigger), D <delay> (delay)\n")
      for i in range(len(rows)):
        f.write("T 1\n")
        f.write(f"D {adc_delay_cycles}\n")
        f.write(f"D {adc_delay_cycles}\n")
    print(f"ADC readout file written to: {adc_filename}")

if __name__ == "__main__":
  main()
